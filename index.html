<!DOCTYPE html>
<html>
<head>
<title>Block Puzzle Game Test</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
    html, body {
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        touch-action: none;
    }
    body { 
        display: flex; 
        flex-direction: column; 
        align-items: center; 
        font-family: Arial, sans-serif; 
        background-color: #2c3e50; 
        color: white;
        margin: 0;
        padding: 10px;
        min-height: 100vh;
        box-sizing: border-box;
    }
    h1 { 
        font-size: clamp(24px, 5vw, 36px);
        margin: 10px 0;
    }
    #gameCanvas { 
        border: 1px solid #ecf0f1; 
        background-color: #34495e; 
        margin-bottom: 20px;
        width: 95vw;
        height: 85vh;
        max-width: 600px;
        max-height: 95vw;
        display: block;
    }
    #scoreBoard { 
        font-size: clamp(18px, 4vw, 24px); 
        margin-bottom: 20px;
    }
    #piecesContainer { 
        display: flex; 
        justify-content: space-between; 
        width: 95vw;
        max-width: 600px;
        margin: 0 auto;
        gap: 2vw;
    }
    .pieceCanvas { 
        border: 1px solid #7f8c8d; 
        margin: 0; 
        background-color: #4a617a;
        width: 28vw;
        height: 28vw;
        max-width: 180px;
        max-height: 180px;
        flex: 1 1 0;
        display: block;
    }
    #gameOverScreen {
        display: none; 
        position: fixed; 
        top: 50%; 
        left: 50%;
        transform: translate(-50%, -50%); 
        background-color: rgba(0,0,0,0.8);
        padding: 20px; 
        border-radius: 10px; 
        text-align: center;
        width: 80%;
        max-width: 300px;
    }
    #gameOverScreen button { 
        padding: 10px 20px; 
        font-size: clamp(16px, 4vw, 18px); 
        margin-top: 20px;
        background-color: #3498db;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
    }
    #gameOverScreen button:hover {
        background-color: #2980b9;
    }
    @media (max-width: 600px) {
        #piecesContainer {
            width: 98vw;
        }
        .pieceCanvas {
            margin: 0;
        }
    }
</style>
</head>
<body>
    <h1>Block Blast Clone</h1>
    <div id="scoreBoard">Score: 0 | Combo: 0</div>
    <canvas id="gameCanvas"></canvas>
    <div id="piecesContainer">
        <canvas class="pieceCanvas" id="pieceCanvas0"></canvas>
        <canvas class="pieceCanvas" id="pieceCanvas1"></canvas>
        <canvas class="pieceCanvas" id="pieceCanvas2"></canvas>
    </div>

    <div id="gameOverScreen">
        <h2>Game Over!</h2>
        <p id="finalScore">Final Score: 0</p>
        <button onclick="startGame()">Play Again</button>
    </div>

<script>
    const COLS = 8;
    const ROWS = 10;

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreBoard = document.getElementById('scoreBoard');
    const pieceCanvases = [
        document.getElementById('pieceCanvas0'),
        document.getElementById('pieceCanvas1'),
        document.getElementById('pieceCanvas2')
    ];
    const pieceCtxs = pieceCanvases.map(pc => pc.getContext('2d'));
    const gameOverScreen = document.getElementById('gameOverScreen');
    const finalScoreDisplay = document.getElementById('finalScore');

    let BLOCK_SIZE;
    let PIECE_CANVAS_SIZE;

    function resizeCanvas() {
        // Get the actual rendered size from CSS
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
        // Calculate block size
        BLOCK_SIZE = Math.floor(Math.min(canvas.width / COLS, canvas.height / ROWS));
        // Centering offsets
        window.boardOffsetX = Math.floor((canvas.width - (BLOCK_SIZE * COLS)) / 2);
        window.boardOffsetY = Math.floor((canvas.height - (BLOCK_SIZE * ROWS)) / 2);
        PIECE_CANVAS_SIZE = 4 * BLOCK_SIZE;
        pieceCanvases.forEach(pc => {
            pc.width = PIECE_CANVAS_SIZE;
            pc.height = PIECE_CANVAS_SIZE;
        });
        if (typeof board !== 'undefined' && board) {
            drawBoard();
        }
        if (typeof currentPieces !== 'undefined' && currentPieces) {
            drawPiecePreviews();
        }
    }

    // Initial canvas setup
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('orientationchange', () => {
        setTimeout(resizeCanvas, 100);
    });

    // Prevent scrolling on touch devices
    document.body.addEventListener('touchmove', function(e) { e.preventDefault(); }, { passive: false });

    let board;
    let score;
    let combo;
    let currentPieces = [];
    let selectedPiece = null;
    let selectedPieceIndex = -1;
    let dragOffsetX, dragOffsetY;
    let lastTouchX, lastTouchY;

    const PIECES = [
        { shape: [[1,1,1,1]], color: 'cyan' }, // I
        { shape: [[1,1],[1,1]], color: 'yellow' }, // O
        { shape: [[1,1,1],[0,1,0]], color: 'purple' }, // T
        { shape: [[1,1,0],[0,1,1]], color: 'green' }, // S
        { shape: [[0,1,1],[1,1,0]], color: 'red' },   // Z
        { shape: [[1,1,1],[1,0,0]], color: 'blue' },  // L
        { shape: [[1,1,1],[0,0,1]], color: 'orange' } // J
        // Add more pieces if desire
    ];

    function getRandomPiece() {
        const pieceData = PIECES[Math.floor(Math.random() * PIECES.length)];
        // Simple rotation for variety - 0 to 3 rotations
        let shape = pieceData.shape;
        const rotations = Math.floor(Math.random() * 4);
        for (let r = 0; r < rotations; r++) {
            shape = rotateMatrix(shape);
        }
        return { ...pieceData, shape: shape, id: Date.now() + Math.random() }; // Unique ID for piece
    }

    function rotateMatrix(matrix) {
        const rows = matrix.length;
        const cols = matrix[0].length;
        const newMatrix = Array(cols).fill(null).map(() => Array(rows).fill(0));
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                newMatrix[c][rows - 1 - r] = matrix[r][c];
            }
        }
        return newMatrix;
    }


    function generateNewPieces() {
        currentPieces = [];
        for (let i = 0; i < 3; i++) {
            currentPieces.push(getRandomPiece());
        }
        drawPiecePreviews();
    }

    function drawBlock(ctxInstance, x, y, color, bSize = BLOCK_SIZE, offsetX = 0, offsetY = 0) {
        ctxInstance.fillStyle = color;
        ctxInstance.fillRect(offsetX + x * bSize, offsetY + y * bSize, bSize, bSize);
        ctxInstance.strokeStyle = '#2c3e50';
        ctxInstance.strokeRect(offsetX + x * bSize, offsetY + y * bSize, bSize, bSize);
    }

    function drawBoard() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                if (board[r][c]) {
                    drawBlock(ctx, c, r, board[r][c], BLOCK_SIZE, window.boardOffsetX, window.boardOffsetY);
                }
            }
        }
    }

    function drawPiecePreviews() {
        pieceCtxs.forEach((pCtx, index) => {
            pCtx.clearRect(0, 0, PIECE_CANVAS_SIZE, PIECE_CANVAS_SIZE);
            if (currentPieces[index]) {
                const piece = currentPieces[index];
                const shape = piece.shape;
                // Center the piece in the preview canvas
                const shapeWidth = shape[0].length * BLOCK_SIZE;
                const shapeHeight = shape.length * BLOCK_SIZE;
                const startX = (PIECE_CANVAS_SIZE - shapeWidth) / 2 / BLOCK_SIZE;
                const startY = (PIECE_CANVAS_SIZE - shapeHeight) / 2 / BLOCK_SIZE;

                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[0].length; c++) {
                        if (shape[r][c]) {
                            drawBlock(pCtx, startX + c, startY + r, piece.color);
                        }
                    }
                }
            }
        });
    }
    
    function drawDraggingPiece(piece, mouseX, mouseY) {
        if (!piece) return;
        const shape = piece.shape;
        for (let r = 0; r < shape.length; r++) {
            for (let c = 0; c < shape[0].length; c++) {
                if (shape[r][c]) {
                    ctx.fillStyle = piece.colorAlpha || piece.color; // Use semi-transparent if available
                    ctx.fillRect(mouseX + c * BLOCK_SIZE - dragOffsetX, 
                                 mouseY + r * BLOCK_SIZE - dragOffsetY, 
                                 BLOCK_SIZE, BLOCK_SIZE);
                     ctx.strokeStyle = '#2c3e50';
                     ctx.strokeRect(mouseX + c * BLOCK_SIZE - dragOffsetX, 
                                 mouseY + r * BLOCK_SIZE - dragOffsetY, 
                                 BLOCK_SIZE, BLOCK_SIZE);
                }
            }
        }
    }


    function canPlace(piece, boardRow, boardCol) {
        const shape = piece.shape;
        for (let r = 0; r < shape.length; r++) {
            for (let c = 0; c < shape[0].length; c++) {
                if (shape[r][c]) {
                    const bR = boardRow + r;
                    const bC = boardCol + c;
                    if (bR < 0 || bR >= ROWS || bC < 0 || bC >= COLS || board[bR][bC]) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    function placePiece(piece, boardRow, boardCol) {
        const shape = piece.shape;
        let blocksPlaced = 0;
        for (let r = 0; r < shape.length; r++) {
            for (let c = 0; c < shape[0].length; c++) {
                if (shape[r][c]) {
                    board[boardRow + r][boardCol + c] = piece.color;
                    blocksPlaced++;
                }
            }
        }
        score += blocksPlaced; // 1 point per block
        return blocksPlaced;
    }

    function checkAndClearLines() {
        let linesCleared = 0;
        let rowsToClear = [];
        for (let r = 0; r < ROWS; r++) {
            if (board[r].every(cell => cell !== 0)) {
                rowsToClear.push(r);
                linesCleared++;
            }
        }

        let colsToClear = [];
        for (let c = 0; c < COLS; c++) {
            let colFull = true;
            for (let r = 0; r < ROWS; r++) {
                if (board[r][c] === 0) {
                    colFull = false;
                    break;
                }
            }
            if (colFull) {
                colsToClear.push(c);
                linesCleared++;
            }
        }
        
        // Clear rows
        for (const r of rowsToClear) {
            for (let c = 0; c < COLS; c++) {
                board[r][c] = 0;
            }
        }
        // Clear columns
        for (const c of colsToClear) {
            for (let r = 0; r < ROWS; r++) {
                board[r][c] = 0;
            }
        }


        if (linesCleared > 0) {
            combo++;
            let lineClearBonus = 0;
            // Simplified scoring for lines & multi-lines
            if (linesCleared === 1) lineClearBonus = 10;
            else if (linesCleared === 2) lineClearBonus = 30;
            else if (linesCleared === 3) lineClearBonus = 60;
            else if (linesCleared >= 4) lineClearBonus = 100;

            // Combo bonus (simplified)
            if (combo > 1) {
                lineClearBonus += (combo -1) * 10; // e.g. combo 2 adds +10, combo 3 adds +20
            }
            score += lineClearBonus;
            console.log(`Cleared ${linesCleared} lines. Combo: ${combo}. Line Bonus: ${lineClearBonus}`);
        } else {
            combo = 0; // Reset combo if no lines cleared
        }
        return linesCleared > 0;
    }

    function updateScoreDisplay() {
        scoreBoard.textContent = `Score: ${score} | Combo: ${combo}`;
    }

    function isGameOver() {
        if (!currentPieces.some(p => p !== null)) return false; // If all pieces are used up, not game over yet until new ones fail

        for (const piece of currentPieces) {
            if (piece === null) continue; // Skip if piece is already used
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (canPlace(piece, r, c)) {
                        return false; // Found a valid move
                    }
                }
            }
        }
        return true; // No piece can be placed
    }

    function handleGameOver() {
        console.log("Game Over!");
        finalScoreDisplay.textContent = `Final Score: ${score}`;
        gameOverScreen.style.display = 'block';
    }

    function startGame() {
        board = Array(ROWS).fill(null).map(() => Array(COLS).fill(0));
        score = 0;
        combo = 0;
        selectedPiece = null;
        selectedPieceIndex = -1;
        gameOverScreen.style.display = 'none';
        generateNewPieces();
        updateScoreDisplay();
    }

    // Event Listeners
    pieceCanvases.forEach((pCanvas, index) => {
        // Mouse events
        pCanvas.addEventListener('mousedown', handlePieceSelection);
        // Touch events
        pCanvas.addEventListener('touchstart', handleTouchStart, { passive: false });

        function handlePieceSelection(e) {
            if (currentPieces[index]) {
                selectedPiece = JSON.parse(JSON.stringify(currentPieces[index]));
                selectedPiece.colorAlpha = selectedPiece.color + '80';
                selectedPieceIndex = index;
                const rect = pCanvas.getBoundingClientRect();
                const clickXInCanvas = e.clientX - rect.left;
                const clickYInCanvas = e.clientY - rect.top;
                // Use the exact click point as drag offset
                dragOffsetX = clickXInCanvas;
                dragOffsetY = clickYInCanvas;
                drawBoard();
                drawDraggingPiece(selectedPiece, clickXInCanvas, clickYInCanvas);
            }
        }

        function handleTouchStart(e) {
            e.preventDefault();
            if (currentPieces[index]) {
                selectedPiece = JSON.parse(JSON.stringify(currentPieces[index]));
                selectedPiece.colorAlpha = selectedPiece.color + '80';
                selectedPieceIndex = index;
                const rect = pCanvas.getBoundingClientRect();
                const touch = e.touches[0];
                const touchXInCanvas = touch.clientX - rect.left;
                const touchYInCanvas = touch.clientY - rect.top;
                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
                // Use the exact touch point as drag offset
                dragOffsetX = touchXInCanvas;
                dragOffsetY = touchYInCanvas;
                drawBoard();
                drawDraggingPiece(selectedPiece, touchXInCanvas, touchYInCanvas);
            }
        }
    });

    // Mouse move handler
    canvas.addEventListener('mousemove', handleMouseMove);
    // Touch move handler
    canvas.addEventListener('touchmove', handleTouchMove, { passive: false });

    function handleMouseMove(e) {
        if (selectedPiece) {
            drawBoard();
            const rect = canvas.getBoundingClientRect();
            drawDraggingPiece(selectedPiece, e.clientX - rect.left, e.clientY - rect.top);
        }
    }

    function handleTouchMove(e) {
        e.preventDefault();
        if (selectedPiece) {
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;
            
            // Smooth out the movement
            if (lastTouchX && lastTouchY) {
                const deltaX = touch.clientX - lastTouchX;
                const deltaY = touch.clientY - lastTouchY;
                if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {
                    drawBoard();
                    drawDraggingPiece(selectedPiece, touchX, touchY);
                }
            }
            
            lastTouchX = touch.clientX;
            lastTouchY = touch.clientY;
        }
    }

    // Mouse up handler
    document.addEventListener('mouseup', handlePiecePlacement);
    // Touch end handler
    document.addEventListener('touchend', handleTouchEnd);

    function handlePiecePlacement(e) {
        if (selectedPiece) {
            const rect = canvas.getBoundingClientRect();
            const mouseXOnBoard = e.clientX - rect.left;
            const mouseYOnBoard = e.clientY - rect.top;
            placePieceOnBoard(mouseXOnBoard, mouseYOnBoard);
        }
    }

    function handleTouchEnd(e) {
        if (selectedPiece) {
            const touch = e.changedTouches[0];
            const rect = canvas.getBoundingClientRect();
            const touchXOnBoard = touch.clientX - rect.left;
            const touchYOnBoard = touch.clientY - rect.top;
            placePieceOnBoard(touchXOnBoard, touchYOnBoard);
            lastTouchX = null;
            lastTouchY = null;
        }
    }

    function placePieceOnBoard(xOnBoard, yOnBoard) {
        const col = Math.floor((xOnBoard - (dragOffsetX - BLOCK_SIZE/2)) / BLOCK_SIZE);
        const row = Math.floor((yOnBoard - (dragOffsetY - BLOCK_SIZE/2)) / BLOCK_SIZE);

        if (canPlace(selectedPiece, row, col)) {
            placePiece(selectedPiece, row, col);
            currentPieces[selectedPieceIndex] = null;
            const linesWereCleared = checkAndClearLines();

            if (currentPieces.every(p => p === null)) {
                generateNewPieces();
            }
        }

        selectedPiece = null;
        selectedPieceIndex = -1;
        drawBoard();
        drawPiecePreviews();
        updateScoreDisplay();

        if (isGameOver()) {
            handleGameOver();
        }
    }
    
    // Initial game start
    startGame();

</script>
</body>
</html>